#!/usr/bin/env python3

import openstack
import sys
import os
import logging
import json

from python_files.create_ssh_config import create_ssh_config_file, write_hosts
from python_files.create_server import create_instance_if_not_exists
from python_files.network_files import get_external_network, get_unused_floating_ip, create_network
from python_files.create_securityGroup import create_security_group
from python_files.openrc import load_openrc
from python_files.ansible_playbook import run_playbook, ansible_ping

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(message)s')

def create_keypair(conn, keypair_name, public_key_path):
    # Get the directory where the script is located
    keypair_name = str(keypair_name) + "_key"
    with open(public_key_path) as public_key:
        public_key = public_key.read()
    existing_keypair = conn.compute.find_keypair(keypair_name)
    if not existing_keypair:
        conn.compute.create_keypair(name=keypair_name, public_key=public_key)
        logging.info(f"Key pair '{keypair_name}' was successfully created.")
    else:
        logging.info(f"Key pair '{keypair_name}' already exists.")

def create_port_keepalived(conn, network, subnet, sec_group):
    # Create a port and attach a floating ip to it 
    keepalived_port = None
    try: 
        keepalived_port = conn.network.find_port('my-keepalived-port')
    except openstack.exceptions.ResourceNotFound:
        keepalived_port = None
        
    if keepalived_port == None:
        keepalived_port = conn.network.create_port(
        name='my-keepalived-port',
        network_id=network.id,
        fixed_ips=[{'subnet_id': subnet.id}],
        security_groups=[sec_group.id],
        )
    
    logging.info("Create a floating ip")
    # create a floating ip 
    external_network_id = get_external_network(conn)
    keepalived_floating_ip = get_unused_floating_ip(conn, external_network_id, fixed_ip=keepalived_port.fixed_ips[0]['ip_address'])
    
    logging.info("Attach floating ip to port")
    # attach a floating ip to the keepalived port
    try:
        conn.network.update_ip(
        keepalived_floating_ip,
        port_id=keepalived_port.id
        )
    except openstack.exceptions.ConflictException: 
        pass
    conn.network.update_port(keepalived_port.id, allowed_address_pairs=[{"ip_address": keepalived_floating_ip.floating_ip_address}])
        
    return keepalived_port, keepalived_floating_ip

def delete_unused_resources(conn, tag):
    delete_unused_routers(conn, tag)
    delete_unused_floating_ips(conn, tag)

def delete_unused_routers(conn, tag):
    routers = conn.network.routers()
    for router in routers:
        router_ports = get_router_ports(conn, router.id)
        if router.name.startswith(tag + "_") and len(router_ports) == 0:
            conn.network.delete_router(router.id)
            logging.info(f"Deleted unused router: {router.name}")

def delete_unused_floating_ips(conn, tag):
    floating_ips = conn.network.ips()
    for ip in floating_ips:
        if ip.description and ip.description.startswith(tag + "_") and ip.fixed_ip_address is None:
            conn.network.delete_ip(ip.id)
            logging.info(f"Deleted unused floating IP: {ip.floating_ip_address}")

def get_router_ports(conn, router_id):
    return [port for port in conn.network.ports(device_id=router_id)]

def validate_operation():
    logging.info("Validation completed.")

def main(openrc, tag, public_key_path):
    logging.info(f"Starting deployment of {tag} using {openrc} for credentials.")
    load_openrc(openrc)
    conn = openstack.connect()

    logging.info(f"Checking if we have floating IPs available.")
    delete_unused_resources(conn, tag)

    logging.info("Creating keypair.")
    create_keypair(conn, tag, public_key_path)

    logging.info("Creating network.")
    network, subnet = create_network(conn, tag)
    
    logging.info("Creating security group.")
    sec_group = create_security_group(conn, tag, subnet)
    
    logging.info("Create a port for keepalived")
    keepalived_port, keepalived_floating_ip = create_port_keepalived(conn, network, subnet, sec_group)
    
    logging.info(f"Creating instances with tag {tag}.")
    instances = {
        f"{tag}_bastion": create_instance_if_not_exists(conn, tag + "_bastion", tag, "Ubuntu 20.04 Focal Fossa x86_64", "1C-4GB-100GB", network.id, sec_group, tag, floating_ip_pool=True),
        f"{tag}_proxy1": create_instance_if_not_exists(conn, tag + "_proxy1", tag, "Ubuntu 20.04 Focal Fossa x86_64", "1C-4GB-100GB", network.id, sec_group, tag, floating_ip_pool=False, allowed_address=keepalived_port.fixed_ips[0]['ip_address']),
        f"{tag}_proxy2": create_instance_if_not_exists(conn, tag + "_proxy2", tag, "Ubuntu 20.04 Focal Fossa x86_64", "1C-4GB-100GB", network.id, sec_group, tag, floating_ip_pool=False, allowed_address=keepalived_port.fixed_ips[0]['ip_address'])
    }
    # Create the number of backend servers as per server.conf
    with open("servers.conf", "r") as file:
        no_servers = file.read()
    for i in range(1, int(no_servers) + 1):
        logging.info(f"Creating the {tag}_dev{i} backend server")
        instances[tag + '_dev' + str(i)] = create_instance_if_not_exists(conn, tag + "_dev" + str(i), tag, "Ubuntu 20.04 Focal Fossa x86_64", "1C-4GB-100GB", network.id, sec_group, tag, floating_ip_pool=False)
        
    # Filter out instances that were not created
    instances = {name: inst for name, inst in instances.items() if inst is not None}

    internal_ips = {name: inst["internal_ip"] for name, inst in instances.items()}
    floating_ips = {name: inst["floating_ip"] for name, inst in instances.items()}

    # Combine internal and floating IPs into a single dictionary
    instance_details = {
        name: {
            "internal_ip": internal_ips.get(name),
            "floating_ip": floating_ips.get(name)
        } for name in instances.keys()
    }

    logging.info(f"Creating the hosts file.")
    write_hosts(tag, instances)
    logging.info(f"Creating SSH configuration file.")

    # Write the instances dictionary to a file
    instances_file_path = os.path.join(os.getcwd(), "instances.json")
    with open(instances_file_path, 'w') as instances_file:
        json.dump(instance_details, instances_file, indent=4)
    logging.info(f"Instances details written to {instances_file_path}")

    # Pass the instances file path to create_ssh_config_file
    create_ssh_config_file(tag, instances_file_path, str(os.path.abspath(public_key_path))[:-4])
    
    logging.info("Ping all hosts")
    if not ansible_ping(tag):
        exit()
    
    logging.info("Executing Ansible playbook.")
    run_playbook(tag, virtual_ip=keepalived_port.fixed_ips[0]['ip_address'])

    validate_operation()

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: install <openrc> <tag> <ssh_key>")
        sys.exit(1)

    main(sys.argv[1], sys.argv[2], sys.argv[3])
    #worked install <openrc> <tag> <ssh_key>
